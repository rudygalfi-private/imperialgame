#summary Additional coding standards beyond what StyleCop enforces.
#labels Phase-Implementation

= Introduction =

Having some additional coding standards beyond what StyleCop offers will be helpful. This page will serve as a place to collect those rules.

In general, these rules will be based in a situation that can be much less mechanically solved than those that StyleCop presents. Still, the hope is that we can make some situations more mechanical by introducing these rules.

= Initialization =

== Declarations ==

If a class has a member that will take on some very logical "default" value, use a declaration to enforce that:

{{{
private uint balance = 0;
}}}

Be cautious of doing this with {{{readonly}}} members as this will prevent constructor assignment:

{{{
private readonly NationName name;
}}}

= Naming =

== Constructor parameters ==

When assigning constructor parameters to private data members, use the same variable name for the parameters as their corresponding data member:

{{{
public BankAccount(uint balance)
{
    this.balance = balance;
}
}}}

C# allows this seeming naming clash so long as we're willing to append our data members with {{{this.}}} each time we call them. This allows us to enforce public-facing well-named constructor parameters.

== Enumerations ==

Enumerations should accompany a closely related class. Since that class will share the same file name, begin the enumeration name with that same class name. This gives more description to the enumeration and allows its containing file to be found easily.

In the rare instance that an enumeration is not closely related to a class or is tied to two or more, place it in its own file named for the enumeration.

= Program Flow =

== Ternary operator ==

The ternary operator ({{{?:}}}) can be used to avoid an if-else construct. It can be especially helpful when that if-else construct has branches that are very similar:

{{{
if (x == y)
{
    return doFunc(a, b, c, x);
}
else
{
    return doFunc(a, b, c, y);
}
}}}

Instead, consider:

{{{
return doFunc(a, b, c, (x == y) ? x : y);
}}}

There are numerous other useful scenarios. However, when using the ternary operator, ensure that the readability of the code does not degrade and that the entire statement involving the operator will fit onto one line. You should be able to very clearly see the separate branches (on either side of the ":") in the ternary operator.

== Enums and switches ==

Use them together! If an enum is coming into a function, it makes sense to handle all of the possible values of that enum in some way. Switches are a very methodical way of ensuring that this gets done.

Exception: Flag-type enums (where the enum values are really representing binary values so that they can be OR'ed together) are exempt.